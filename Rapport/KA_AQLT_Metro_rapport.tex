\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[,french]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={Itinéraire entre deux stations du métro parisien},
            pdfauthor={Kim Antunez et Alain Quartier-la-Tente},
            colorlinks=true,
            linkcolor=Maroon,
            filecolor=Maroon,
            citecolor=Blue,
            urlcolor=blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=1in]{geometry}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\usepackage{pdflscape}
\newcommand{\blandscape}{\begin{landscape}}
\newcommand{\elandscape}{\end{landscape}}
\usepackage{fontawesome5}
\usepackage{caption}
\usepackage{tikz}
\usepackage[tikz]{bclogo}
\usepackage{changepage}
% https://github.com/rstudio/rmarkdown/issues/337
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

% https://github.com/rstudio/rmarkdown/pull/252
\usepackage{titling}
\setlength{\droptitle}{-2em}

\pretitle{\vspace{\droptitle}\centering\huge}
\posttitle{\par}

\preauthor{\centering\large\emph}
\postauthor{\par}

\predate{\centering\large\emph}
\postdate{\par}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[shorthands=off,main=]{babel}
\else
  % load polyglossia as late as possible as it *could* call bidi if RTL lang (e.g. Hebrew or Arabic)
  \usepackage{polyglossia}
  \setmainlanguage[]{}
\fi

\title{Itinéraire entre deux stations du métro parisien}
\author{Kim Antunez et Alain Quartier-la-Tente}
\date{07/01/2020 - 15h30 à 15h45}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

Ce rapport décrit le projet C++ de Kim Antunez et d'Alain
Quartier-la-Tente (Ensae, 2A) dont l'objectif est de permettre à
l'utilisateur d'obtenir un itinéraire entre deux stations de métro selon
deux critères : le plus court chemin ou le chemin avec le moins de
correspondances. L'ensemble des données et des codes utilisés sont
disponibles sous \url{https://github.com/AQLT/Metro_Cpp}, la section
\ref{sec:le_programme} décrivant comment utiliser l'application. Les
données utilisées sont les données du métro parisien fournies par la
RATP (section \ref{sec:def_donnees}), l'implémentation des classes est
décrite dans la section \ref{sec:desc_classes}, l'algorithme utilisé
pour calculer les chemins est l'algorithme de Dijkstra (section
\ref{sec:algo}). Enfin, les pistes d'amélioration sont décrites dans la
partie \ref{sec:amelioration}.

Pour mieux se retrouver dans le réseau parisien, et surtout tester la
validité de l'algorithme, le plan de l'ensemble des lignes a été rajouté
dans la section \ref{sec:lignes_metro}.

\hypertarget{sec:le_programme}{%
\section{Le programme}\label{sec:le_programme}}

\hypertarget{prise-en-main}{%
\subsection{Prise en main}\label{prise-en-main}}

Afin de s'assurer que le programme tourne bien sur votre ordinateur.
Veillez à effectuer les vérifications suivantes sur le fichier
\texttt{main.cpp} :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Changer le répertoire de travail (\texttt{project\_directory}) : il
  doit s'agir du lien vers le dossier contenant le dossier
  \texttt{Data\ Projet}. Ainsi, si l'archive a été dézippée sous
  \texttt{D:/}, \texttt{project\_directory} doit être égale à
  \texttt{D:/Metro\_Cpp}.
\item
  Choisir si l'on veut mettre la couleur (booléen
  \texttt{activerCouleur}).\\
  \bcattention  \textbf{Attention} : la coloration de la console utilise
  la librairie \texttt{windows.h} et n'est donc compatible que sous les
  ordinateurs sous Windows. Dans le cas contraire, ouvrir le fichier
  \texttt{IHM.h} et supprimer la ligne 6 contenant
  \texttt{\#include\ \textless{}windows.h\textgreater{}}.
\item
  Lancer le programme est se laisser guider.
\end{enumerate}

\includegraphics{img/main.png}

\hypertarget{duxe9monstration}{%
\subsection{Démonstration}\label{duxe9monstration}}

\hypertarget{sec:def_donnees}{%
\section{Description des données}\label{sec:def_donnees}}

\hypertarget{description-des-donnuxe9es-uxe0-disposition}{%
\subsection{Description des données à
disposition}\label{description-des-donnuxe9es-uxe0-disposition}}

Toutes les données utilisées dans ce projet sont issues de la RATP, plus
précisément de la base \texttt{offre-transport-de-la-ratp-format-gtfs}
(\url{https://dataratp.opendatasoft.com/explore/dataset/offre-transport-de-la-ratp-format-gtfs/information/}).
Ces données sont au format \emph{General Transit Feed Specification}
(GTFS) qui est un format standardisé pour diffuser des données relatives
aux réseaux de transport en commun (horaires, informations
géographiques, etc.).

Pour les données de la RATP sont disponibles sous deux formes d'archives
:

\begin{itemize}
\tightlist
\item
  Une archive avec des fichiers GTFS réparties par lignes ;\\
\item
  Une archive avec des fichiers GTFS pour l'ensemble du réseau (métro,
  bus, tram et RER).
\end{itemize}

C'est la première archive que nous avons utilisée. En effet, nous
restreignons notre étude aux lignes de métro uniquement. Nous avons
stocké les données utilisées ici :
\url{https://github.com/AQLT/Metro_Cpp/tree/master/Data}.

Chaque ligne de métro est associée à un dossier qui contient des données
stockées dans différents fichiers :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{routes.txt} : définit les itinéraires des transports en commun
  \(\rightarrow\) données \textbf{utilisées} avec le fichier
  \texttt{trips.txt} pour identifier l'ordre de passage à chaque arrêt
  pour les lignes aller et retour.
\item
  \texttt{stops.txt} : définit l'ensemble des arrêts où les usages
  peuvent monter ou descendre, avec le nom de l'arrêt, l'adresse et les
  coordonnées GPS \(\rightarrow\) données \textbf{utilisées} dans ce
  projet pour définir l'ensemble des arrêts.
\item
  \texttt{stop\_times.txt} : définit, pour chaque trajet et pour chaque
  arrêt, les heures d'arrivée et de départ du métro \(\rightarrow\)
  données \textbf{utilisées} avec le fichier \texttt{trip.txt} pour
  connaître le temps de trajet entre deux stations de la même ligne.
\item
  \texttt{transfers.txt} : définit les règles de liaison aux pôles de
  correspondance entre des itinéraires \(\rightarrow\) données
  \textbf{utilisées} dans ce projet pour connaître les correspondances
  et les temps de correspondance entre les lignes.
\item
  \texttt{trips.txt} : définit l'ensemble des trajets pour chaque ligne
  (i.e. : tous les trajets prévus dans la journée) \(\rightarrow\)
  données \textbf{utilisées} avec le fichier \texttt{routes.txt} et
  \texttt{stop\_times.txt} pour identifier pour chaque ligne l'ordre de
  passage et le temps de trajet entre chaque arrêt \footnote{Dans ce
    projet nous ne prenons pas en compte l'heure à laquelle la recherche
    d'itinéraire a été faite : pour chaque ``route'' un seul ``trip'' a
    donc été utilisé.}.
\item
  \texttt{calendar\_dates.txt} : définit les exceptions pour les
  services définis dans le fichier \texttt{calendar.txt} \(\rightarrow\)
  données \textbf{non utilisées} dans ce projet.
\item
  \texttt{calendar.txt} : définit les dates auxquelles le service est
  disponible pour des itinéraires spécifiques selon un calendrier
  hebdomadaire. Ce fichier spécifie les dates de début et de fin du
  service, ainsi que les jours de la semaine où le service est
  disponible \(\rightarrow\) données \textbf{non utilisées} dans ce
  projet.
\item
  \texttt{agency.txt} : définit une ou plusieurs agences de transports
  publics dont les services sont représentés dans l'ensemble de données
  \(\rightarrow\) données \textbf{non utilisées} dans ce projet.
\end{enumerate}

Plus d'informations sur les données GTFS sont disponibles sur le site de
Google : \url{https://developers.google.com/transit/gtfs/reference/}.

\hypertarget{difficultuxe9s-et-solutions-adoptuxe9es}{%
\subsection{Difficultés et solutions
adoptées}\label{difficultuxe9s-et-solutions-adoptuxe9es}}

Chaque arrêt est défini par une identifiant unique. Cet identifiant est
différent pour chaque ligne et pour chaque route (aller et retour) sans
qu'aucune durée de correspondance n'ait été définie dans les données.
Certains itinéraires étaient donc impossibles à calculer avec
l'utilisation de ces seules données brutes. Par exemple, si l'on est à
l'arrêt de métro Gaîté sur la ligne 13 direction Châtillon-Montrouge on
ne peut pas rejoindre l'arrêt Montparnasse car la ligne est orientée
dans la ``mauvaise direction''. \(\rightarrow\) \textbf{Solution
adoptée} : ajouter un temps de transfert égal à 0 permettant de passer
d'un arrêt d'une ligne aller à ce même arrêt (même nom) de la ligne
retour, et inversement. Ainsi, le temps de transfert est nul pour passer
de l'arrêt de métro Gaîté sur la ligne 13 direction Châtillon-Montrouge
à l'arrêt de métro Gaîté sur la ligne 13 direction Saint-Denis/Les
Courtilles. En revanche cela rend le calcul du temps de trajet moins
fiable pour deux raisons :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Le temps de transfert entre deux lignes n'est pas le même en fonction
  de la direction que l'on prend.
\item
  Pour réaliser certains itinéraires, il est nécessaire de changer de
  direction tout en restant sur la même ligne (par exemple sur la ligne
  13 passer de Guy Môquet à Brochant il faut aller jusqu'à l'arrêt La
  Fourche et changer de direction). 
\end{enumerate}

Puisque nous avons fait le choix de ne pas tenir compte du temps
d'attente moyen d'un métro, \textbf{le temps de trajet prévu pour chaque
itinéraire est sous-estimé}.

Cette façon de numéroter les arrêts implique que certains arrêts ne sont
associés qu'à une ligne (aller ou retour) alors que d'autres sont
associés à deux lignes (par exemple sur la ligne 13 qui contient 2
lignes aller ou 2 lignes retour).

Plusieurs incohérences ont également été trouvées dans les données qui
concernent les trajets :

\begin{itemize}
\item
  Le fichier \texttt{routes.txt} ne permettait pas toujours de bien
  identifier les lignes aller et retour. En effet, pour certaines lignes
  de métro, pour le même identifiant de ``trip'' et pour une ``route''
  fixée, il pouvait y avoir au même horaire un départ d'un terminus pour
  une direction et du terminus opposé pour l'autre direction. Cela
  devrait normalement être impossible puisque la ``route'' permet
  d'identifier la direction. Ce problème affecte les lignes 1, 4, 7, 7B
  et 13 : un travail manuel sur les bases de données a donc été réalisé
  pour identifier correctement les lignes aller et retour.\\
\item
  Certaines ``routes'' de la base de données ne correspondent pas à la
  réalité du réseau du métro parisien. C'est le cas d'une des routes de
  la ligne 10 ``BOULOGNE - PONT DE SAINT CLOUD
  \textless{}-\textgreater{} GARE D'AUSTERLITZ) - Aller'' qui partirait
  de l'arrêt Porte d'Auteuil pour ensuite aller à l'arrêt Michel-Ange
  Molitor et continuer direction Gare D'Austerlitz (alors que depuis
  Porte d'Auteuil la seule direction possible est Boulogne). Cette
  ``route'' n'a alors pas été considérée dans notre algorithme.
\end{itemize}

Pour simplifier le chargement des données en C++, nous avons pré-traité
les données via le logiciel statistique \faRProject :

\begin{itemize}
\tightlist
\item
  Pour chaque ligne de métro nous avons créé un dossier avec :

  \begin{itemize}
  \item
    Le fichier \texttt{stops.txt} dans lequel nous avons enlevé les
    accents (permet de créer l'ensemble des arrêts) ; \footnote{le
      logiciel Code::Blocks utilisé sur les postes Windows de l'Ensae
      génère en effet des problèmes d'encodage, ce qui ne permet pas par
      exemple d'afficher correctement les caractères accentués.}.
  \item
    Un fichier par ``route'' contenant l'ensemble des arrêts de manière
    ordonnée ainsi que le nom de la route (ce qui permet d'identifier
    les arrêts traversés par une ligne ainsi que l'ordre de passage).
  \end{itemize}
\end{itemize}

\begin{itemize}
\tightlist
\item
  Deux matrices carrées ayant autant de colonnes et de lignes que
  d'identifiants d'arrêts :
\end{itemize}

\begin{verbatim}
+ `voisins_type.txt` : la coordonnée (i,j) vaut -1 si les deux arrêts ne sont pas directement connectés, 0 si les deux arrêts en fait "les mêmes" (i.e. : ce sont des arrêts qui ont le même nom et le même numéro de ligne, cf. plus haut)  et 1 si les deux arrêts sont connectés mais sur deux lignes différentes (par exemple entre la ligne 4 et la ligne 13 à l'arrêt Montparnasse).

+ `voisins.txt` : la coordonnée (i,j) correspond au temps nécessaire pour aller directement l'arrêt i à l'arrêt j. Avec une valeur égale à -1 s'il n'y a pas de correspondance directe possible et à 0 si 0 si les deux arrêts en fait "les mêmes" (i.e. : ce sont des arrêts qui ont le même nom et le même numéro de ligne, cf. plus haut).
\end{verbatim}

Les fichiers utilisés dans l'implémentation C++ sont disponibles sous
\url{https://github.com/AQLT/Metro_Cpp/tree/master/Data\%20projet}.

\hypertarget{sec:desc_classes}{%
\section{Description des classes}\label{sec:desc_classes}}

Pour l'implémentation de ce projet C++, nous avons créé huit classes qui
pouvant être rassemblées en quatre groupes :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Les classes liées à la représentation des données du métro parisien.
  Il s'agit des classes \texttt{Arret}, \texttt{Ligne} et
  \texttt{Metro}.
\item
  Les classes liées à l'algorithme du plus court chemin. Il s'agit des
  classes \texttt{Node}, \texttt{Edge} et \texttt{Graphe}.
\item
  Une classe permettant de faire le lien entre les données et
  l'algorithme. Il s'agit de la classe \texttt{Itineraire}.
\item
  Une classe générant l'Interface Homme-Machine. Il s'agit de la classe
  \texttt{IHM}.
\end{enumerate}

La figure \ref{fig:diag_classes} décrit les relations entre toutes ces
classes. Elle reprend un certain nombre de conventions d'un diagramme de
classe en UML. Comme par exemple :

\begin{itemize}
\tightlist
\item
  Les objets de type public sont préfixés d'un ``+'' et ceux de type
  privé d'un ``-''
\end{itemize}

Sans pour autant respecter toutes ses normes. Comme par exemple :

\begin{itemize}
\tightlist
\item
  Les constructeurs ne figurent pas sur ce schéma, à l'exception d'un
  des constructeurs d'Itineraire.
\end{itemize}

\begin{figure}[h]
\includegraphics{img/Diagramme_classes/diagramme_classes.pdf} 
\captionsetup{margin=0cm,format=hang,justification=justified}
\caption{Liens entre les classes du projet}\label{fig:diag_classes}

 \footnotesize
Note de lecture : Les objets de type public sont préfixés d'un "+" et ceux de type privé d'un "-". 
Les constructeurs ne figurent pas sur ce schéma, à l'exception d'un des constructeurs d'Itineraire. 
\end{figure}

Des informations supplémentaires sur les méthodes mobilisées dans chaque
classe sont disponibles dans le code du projet.

\hypertarget{classes-liuxe9es-au-ruxe9seau-de-muxe9tro-parisien}{%
\subsection{Classes liées au réseau de métro
parisien}\label{classes-liuxe9es-au-ruxe9seau-de-muxe9tro-parisien}}

À partir des données décrites dans la section \ref{sec:def_donnees},
nous avons créé quatre classes :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  La classe \texttt{Arret} est la classe qui représente un arrêt de
  métro tel que définit dans la base de données de la RATP : il dépend
  donc du numéro de la ligne ainsi que de la direction. Il y a donc par
  exemple deux objets \texttt{Arret} associés à l'arrêt ``Gaîté'' (un
  qui correspond à l'arrêt Gaîté sur la ligne 13 direction
  Châtillon-Montrouge et un qui correspond à l'arrêt Gaîté sur la ligne
  13 direction Saint-Denis/Les Courtilles) et quatre objets
  \texttt{Arret} associés à l'arrêt Denfert-Rochereau (deux sur la ligne
  4 et deux sur la ligne 5). Chaque arrêt peut être associé à un ou
  plusieurs objets \texttt{Ligne}.
\item
  La classe \texttt{Ligne} représente un ensemble ordonné d'objets
  \texttt{Arret} et définissent l'ensemble des arrêts d'une ligne et est
  associé à une direction. Ainsi, pour la ligne 4 il y a deux objets
  \texttt{Ligne} qui correspondent au chemin de la ligne 4 direction
  Mairie de Montrouge et au chemin de la ligne 4 direction Porte de
  Clignancourt. De la même façon pour la ligne 13 il y a quatre objets
  \texttt{Ligne}.
\item
  La classe \texttt{Metro} est la classe qui synthétise le réseau : elle
  contient l'ensemble des objets \texttt{Arret} et l'ensemble des objets
  \texttt{Ligne}.
\end{enumerate}

\hypertarget{classes-liuxe9es-uxe0-lalgorithme-du-plus-court-chemin}{%
\subsection{Classes liées à l'algorithme du plus court
chemin}\label{classes-liuxe9es-uxe0-lalgorithme-du-plus-court-chemin}}

Trois classes ont été créées pour implémenter l'algorithme de Dijkstra :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  La classe \texttt{Node} est la classe qui représente un sommet. Chaque
  sommet est associé à un identifiant (qui correspond à un identifiant
  d'un \texttt{Arret}) et possède plusieurs paramètres qui seront
  actualisés pendant l'algorithme de Dijkstra (voir section
  \ref{sec:algo}).
\item
  La classe \texttt{Edge} est la classe qui représente une arête.
  C'est-à-dire qu'un \texttt{Edge} représente un lien entre un
  \texttt{Node} 1 vers un \texttt{Node} avec la distance entre ces deux
  objets qui vaut :
\end{enumerate}

\begin{itemize}
\tightlist
\item
  soit le temps de correspondance/temps de trajet entre deux arrêts si
  l'on souhaite calculer l'itinéraire le plus court
\item
  soit la valeur de l'indicatrice d'être sur la même ligne si l'on
  souhaite calculer l'itinéraire avec le moins de changements.
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  La classe \texttt{Graphe} est la classe qui synthétise le réseau du
  côté algorithmique : elle contient l'ensemble des \texttt{Node} et des
  \texttt{Edge} et permet de calculer le plus court chemin.
\end{enumerate}

\hypertarget{classe-faisant-le-lien-entre-lalgorithme-et-les-donnuxe9es}{%
\subsection{Classe faisant le lien entre l'algorithme et les
données}\label{classe-faisant-le-lien-entre-lalgorithme-et-les-donnuxe9es}}

La classe \texttt{Itineraire} permet de faire le lien entre les données
et le résultat de l'algorithme du plus court chemin. Son constructeur
utilise le \texttt{Node} d'arrivée et le \texttt{Metro} pour :

\begin{itemize}
\item
  retracer l'ensemble des \texttt{Node} parcourus dans le plus court
  chemin et en déduire l'ensemble des \texttt{Arret} parcourus pour
  effectuer l'itinéraire ;
\item
  calculer le temps nécessaire pour effectuer le trajet.
\end{itemize}

Elle fournit également quelques fonctions pour faciliter l'affichage du
résultat par l'\texttt{IHM}.

\hypertarget{classe-guxe9nuxe9rant-linterface-homme-machine}{%
\subsection{Classe générant l'Interface
Homme-Machine}\label{classe-guxe9nuxe9rant-linterface-homme-machine}}

Une classe \texttt{IHM} a été créée pour gérer l'interface
homme-machine. Elle contient quatre grandes fonctionnalités qui
correspondent à un découpage de l'affichage du menu en quatre parties :

\begin{itemize}
\item
  \texttt{choixDepartArrivee()} qui, à partir d'un objet \texttt{Metro},
  permet à l'utilisateur de choisir sa station de métro de départ puis
  d'arrivée ;
\item
  \texttt{afficherItineraire()} qui, à partir d'un objet
  \texttt{Itineraire}, récupère les principales informations à afficher
  à l'utilisateur concernant son itinéraire (station de départ,
  d'arrivée, correspondances, temps de trajet\ldots{});
\item
  \texttt{choixTypeItineraire()} qui permet à l'utilisateur de choisir
  un type d'itinéraire (plus court chemin ou le moins de
  correspondances)
\item
  \texttt{quitter()} qui permet à l'utilisateur de quitter
  l'application.
\end{itemize}

\hypertarget{sec:algo}{%
\section{L'algorithme de Dijkstra}\label{sec:algo}}

L'algorithme de Dijkstra permet de trouver le chemin le plus court entre
deux sommets d'un graphe.

Par simplification, l'algorithme est ci-dessous présenté grâce à un
exemple fictif, qui fait également référence aux
\textcolor{orange}{fonctions}, \textcolor{blue}{paramètres} et
\textcolor{purple}{objets} utilisés dans notre code.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  En entrée, nous partons d'un graphe (\textcolor{purple}{Graphe})
  composé de sommets (\textcolor{purple}{Node}) reliées par des arêtes
  (\textcolor{purple}{Edge}) auxquelles on associe une distance.
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A) at (0,0) {};
    \node (B) at (1,-3) {};
    \node (C) at (3,-2) {};
    \node (D) at (4,0) {};
    \node (E) at (7,-3) {};
    \node (F) at (9,-1) {} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge node {$4$} (B);
    \path  (B) edge node {$2$} (C);
    \path  (A) edge node {$4$} (C);
    \path  (C) edge node {$3$} (D);
    \path  (C) edge node {$1$} (E);
    \path  (C) edge node {$6$} (F);
    \path  (D) edge node {$2$} (F);
    \path  (E) edge node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}

\emph{Remarque :} Dans l'exemple choisi ici, le graphe n'est pas orienté
: si le sommet A est relié au sommet B, cela implique que B est aussi
relié à A et la distance de A vers B est égale à celle de B vers A. Dans
les données de la RATP que nous utilisons, le graphe est, lui, orienté.
Toutefois, l'algorithme fonctionne de la même façon dans ce cadre.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Choisir un sommet de départ. Lui attribuer un attribut de distance
  (\textcolor{blue}{Node.distanceFromStart}) égal à 0. Attribuer une
  valeur infinie à distanceFromStart pour tous les autres sommets.
\end{enumerate}

\begin{center}
\usetikzlibrary{arrows.meta}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B) at (1,-3) {$\infty$};
    \node (C) at (3,-2) {$\infty$};
    \node (D) at (4,0) {$\infty$};
    \node (E) at (7,-3) {$\infty$};
    \node (F) at (9,-1) {$\infty$} ;
\end{scope}

\begin{scope}[every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge node {$4$} (B);
    \path  (B) edge node {$2$} (C);
    \path  (A) edge node {$4$} (C);
    \path  (C) edge node {$3$} (D);
    \path  (C) edge node {$1$} (E);
    \path  (C) edge node {$6$} (F);
    \path  (D) edge node {$2$} (F);
    \path  (E) edge node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}
\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{On s’intéresse tout d’abord au sommet le plus à gauche coloré en noir.}
\end{center}
\end{adjustwidth}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Pour tous les sommets adjacents à ce sommet de départ, actualiser le
  distanceFromStart du sommet avec la valeur égale à la distance entre
  le sommet de départ et ce sommet. On note également par où on passe :
  pour chaque sommet actualisé, on note la valeur du sommet précédent
  (\textcolor{blue}{Node.previous} est ici égal au sommet de départ).
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B) at (1,-3) {4};
    \node (C) at (3,-2) {4};
    \node (D) at (4,0) {$\infty$};
    \node (E) at (7,-3) {$\infty$};
    \node (F) at (9,-1) {$\infty$} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge[dashed] node {$4$} (B);
    \path  (B) edge node {$2$} (C);
    \path  (A) edge[dashed] node {$4$} (C);
    \path  (C) edge node {$3$} (D);
    \path  (C) edge node {$1$} (E);
    \path  (C) edge node {$6$} (F);
    \path  (D) edge node {$2$} (F);
    \path  (E) edge node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}
\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{Ici on actualise donc la valeur du distanceFromStart des deux sommets voisins du sommet de départ à la valeur de 4.}

\end{center}

\end{adjustwidth}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Choisir un « sommet voisin » (nous allons voir en étape 6 comment
  précisément le choisir). Sommer ensuite la valeur de la
  distanceFromStart du « sommet précédent » à la distance entre ce «
  sommet précédent » et le « sommet voisin » (dist =
  \textcolor{orange}{calculerDistance()}). Si l'ancienne
  distanceFromStart associée au « sommet voisin » est supérieure à «
  dist » alors on la modifie à « dist ». On passe ensuite au sommet
  suivant.
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B)[white, thick,draw,fill=black] at (1,-3) {4};
    \node (C)[label distance=0.1cm, label={below:\small $4+2>4$}] at (3,-2) {4};
    \node (D) at (4,0) {$\infty$};
    \node (E) at (7,-3) {$\infty$};
    \node (F) at (9,-1) {$\infty$} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge[dashed] node {$4$} (B);
    \path  (B) edge[dashed] node {$2$} (C);
    \path  (A) edge node {$4$} (C);
    \path  (C) edge node {$3$} (D);
    \path  (C) edge node {$1$} (E);
    \path  (C) edge node {$6$} (F);
    \path  (D) edge node {$2$} (F);
    \path  (E) edge node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}
\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{Ici, on s’intéresse par exemple dans un deuxième temps
au sommet en bas à gauche puis dans un troisième temps à son voisin
de droite. On laisse la valeur de 4 à ce voisin de droite car 6 > 4.}

\end{center}

\end{adjustwidth}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Continuer à parcourir le graphe.
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B)[white, thick,draw,fill=black] at (1,-3) {4};
    \node (C)[white, thick,draw,fill=black] at (3,-2) {4};
    \node (D)[label={[label distance=0.1cm]\small $4+3$}] at (4,0) {7};
    \node (E)[label={[label distance=0.1cm]below:\small $4+5$}] at (7,-3) {5};
    \node (F)[label={[label distance=0.1cm]right:\small $4+6$}] at (9,-1) {10} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge node {$4$} (B);
    \path  (B) edge[dashed] node {$2$} (C);
    \path  (A) edge[dashed] node {$4$} (C);
    \path  (C) edge[dashed] node {$3$} (D);
    \path  (C) edge[dashed] node {$1$} (E);
    \path  (C) edge[dashed] node {$6$} (F);
    \path  (D) edge node {$2$} (F);
    \path  (E) edge node {$3$} (F);
\end{scope}
\end{tikzpicture}

\end{center}

\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{Ici, on calcule par exemple les distanceFromStart de tous les voisins du sommet central non parcourus.}
\end{center}
\end{adjustwidth}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  Àchaque itération, identifier tout d'abord les voisins restant à
  parcourir (\textcolor{orange}{adjacentRemainingNodes()}) et choisir le
  sommet non visité pour lequel la distanceFromStart est la plus petite
  (\textcolor{orange}{extractSmallest()}).
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B)[white, thick,draw,fill=black] at (1,-3) {4};
    \node (C)[white, thick,draw,fill=black] at (3,-2) {4};
    \node (D) at (4,0) {7};
    \node (E)[white, thick,draw,fill=black] at (7,-3) {5};
    \node (F)[label={[label distance=0.1cm]right:\small $5+3<10$}] at (9,-1) {8} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge node {$4$} (B);
    \path  (B) edge node {$2$} (C);
    \path  (A) edge node {$4$} (C);
    \path  (C) edge node {$3$} (D);
    \path  (C) edge[dashed] node {$1$} (E);
    \path  (C) edge node {$6$} (F);
    \path  (D) edge node {$2$} (F);
    \path  (E) edge[dashed] node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}
\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{En quatrième étape, nous étudions donc le sommet le plus en bas (5) avant celui le plus en haut (7)
(5 < 7).}\end{center}
\end{adjustwidth}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Continuer à parcourir le graphe.
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B)[white, thick,draw,fill=black] at (1,-3) {4};
    \node (C)[white, thick,draw,fill=black] at (3,-2) {4};
    \node (D)[white, thick,draw,fill=black] at (4,0) {7};
    \node (E)[white, thick,draw,fill=black] at (7,-3) {5};
    \node (F) at (9,-1) {8} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge node {$4$} (B);
    \path  (B) edge node {$2$} (C);
    \path  (A) edge node {$4$} (C);
    \path  (C) edge[dashed] node {$3$} (D);
    \path  (C) edge node {$1$} (E);
    \path  (C) edge node {$6$} (F);
    \path  (D) edge[dashed] node {$2$} (F);
    \path  (E) edge node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}

\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{Le distanceFromStart du sommet le plus à droite est alors mis à jour deux fois.}
\end{center}
\end{adjustwidth}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  Enregistrer les chemins parcourus à chaque étape et répéter jusqu'à ce
  que toutes les arêtes soient visitées \footnote{On pourrait
    spécialiser l'algorithme en arrêtant de parcourir le graphe une fois
    le sommet d'arrivée atteint. En revanche, le temps de calcul étant
    relativement faible le gain serait limité.}. Il est alors possible
  en choisissant un sommet d'arrivée de retracer le chemin le plus court
  à parcourir et les distances parcourus entre chaque sommet.
\end{enumerate}

\begin{center}
\begin{tikzpicture}
\begin{scope}[every node/.style={circle,thick,draw,minimum size=0.7cm}]
    \node (A)[white, thick,draw,fill=black] at (0,0) {0};
    \node (B)[white, thick,draw,fill=black] at (1,-3) {4};
    \node (C)[white, thick,draw,fill=black] at (3,-2) {4};
    \node (D)[white, thick,draw,fill=black] at (4,0) {7};
    \node (E)[white, thick,draw,fill=black] at (7,-3) {5};
    \node (F)[white, thick,draw,fill=black] at (9,-1) {8} ;
\end{scope}

\begin{scope}[
              every node/.style={fill=white,circle},
              every edge/.style={draw=black,ultra thick}]
    \path  (A) edge node {$4$} (B);
    \path  (B) edge node {$2$} (C);
    \path  (A) edge node {$4$} (C);
    \path  (C) edge node {$3$} (D);
    \path  (C) edge node {$1$} (E);
    \path  (C) edge[dashed] node {$6$} (F);
    \path  (D) edge[dashed] node {$2$} (F);
    \path  (E) edge[dashed] node {$3$} (F);
\end{scope}
\end{tikzpicture}
\end{center}

\begin{adjustwidth}{50pt}{50pt}
\begin{center}
\emph{L’algorithme se termine : tous les sommets sont parcourus.}
\end{center}
\end{adjustwidth}

L'implémentation choisie dans le cadre de ce projet reprend ces
différentes étapes. Il ne s'agit pas de la méthode la plus optimale en
termes de temps de calcul mais, en revanche, de la méthode la plus
lisible (classes et fonctions plus facilement compréhensibles). Par
ailleurs, du fait de la petite taille du graphe utilisé dans le projet,
le gain qui découlerait d'une optimisation du temps de calcul serait
négligeable.

\hypertarget{sec:amelioration}{%
\section{Pistes d'amélioration}\label{sec:amelioration}}

Plusieurs points peuvent être améliorés :

\begin{itemize}
\item
  Le format matriciel utilisé pour stocker les temps de correspondances
  et de trajet n'est pas optimal puisque cela oblige à lire les
  informations sur tous les sommets non reliés entre eux et à parcourir
  deux fois la matrice pour charger les deux types de distance. Le temps
  de chargement des données pourrait être amélioré de façon conséquente
  en créant un fichier dont chaque ligne contient deux identifiants
  d'arrêts et les distances pour le chemin le plus court et le chemin
  avec le moins de changement.
\item
  Nous n'avons pas pris en compte l'horaire dans notre projet. C'est par
  exemple ce qui explique que nous n'avons pas intégré les lignes de
  RER. Une façon de gérer l'heure (et la date) serait de rajouter dans
  la classe \texttt{Edge} un vecteur contenant l'ensemble des horaires
  de passage. Pendant la mise à jour des distances des \texttt{Node} de
  l'algorithme, il faut alors :

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \item
    mettre à jour la valeur de \textcolor{blue}{Node.distanceFromStart}
    comme étant égale à la somme entre le temps de correspondance et la
    différence entre l'horaire du prochain passage et l'horaire actuelle
    ;
  \item
    incrémenter l'horaire actuelle de cette somme.
  \end{enumerate}
\item
  Lorsque deux itinéraires ont un temps de trajet ``proche'' (par
  exemple dont le temps de trajet est inférieur à 2 minutes), on
  pourrait afficher les deux possibilités.
\end{itemize}

D'autres informations pourraient être utilisées pour proposer d'autres
fonctionnalités. Par exemples les coordonnées GPS (disponibles dans la
classe \texttt{Arret}) pourraient être utilisées pour :

\begin{itemize}
\item
  Calculer l'itinéraire en prenant en compte le temps de marche
  nécessaire pour aller au plus proche métro.
\item
  Prendre en compte le réseau de bus.
\item
  Ajouter d'autres types d'itinéraires comme le calcul d'un itinéraire
  en passant par des toilettes publiques de la RATP :
  \url{https://dataratp.opendatasoft.com/explore/dataset/sanitaires-reseau-ratp}.
\end{itemize}

\hypertarget{sec:lignes_metro}{%
\section{Lignes de métro}\label{sec:lignes_metro}}

\begin{figure}
\centering
\includegraphics{img/plan_lignes/Plan-Metro.pdf}
\caption{Plan général du réseau de transport parisien (hors bus)}
\end{figure}

\newpage
\begin{landscape}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-1.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-2.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-3.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-3b.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-4.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-5.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-6.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-7.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-7b.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-8.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-9.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-10.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-11.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-12.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-13.pdf}

\includegraphics{img/plan_lignes/plan-de-ligne_metro_ligne-14.pdf}

\end{landscape}

\newpage

\end{document}
